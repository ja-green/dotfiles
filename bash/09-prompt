unset PS1

std_time24() { 
    echo "$(date +%H:%M)"
}

std_prompt() {
    [[ "${EUID}" = "0" ]] && echo "#" || echo "$" 
}

git_branch() {
    local git_status="$(git status 2> /dev/null)"
    local on_branch="On branch ([^${IFS}]*)"
    local on_commit="HEAD detached at ([^${IFS}]*)"

    if [[ ${git_status} =~ ${on_branch} ]]; then
        echo "${BASH_REMATCH[1]}"
    elif [[ ${git_status} =~ ${on_commit} ]]; then
        echo ":${BASH_REMATCH[1]}"
    
    elif [ -d "${gitdir}/rebase-merge" ] || [ -d "${gitdir}/rebase-apply" ]; then
        echo "$(basename $(cat ${gitdir}/rebase-*/head-name))"
    elif [ -d "${gitdir}/BISECT_LOG" ]; then
        echo "$(basename $(cat ${gitdir}/BISECT_START))"
    else 
        echo "$(git rev-parse --short HEAD)"
    fi
}

git_status() {
    git status --porcelain | (
      while read line ; do
          case "${line//[[:space:]]/}" in
            @('M'|'UU')*)  dty="\001${YLW}\002\u25CF\001${RST}\002" ; ;;
            'D'*)          del="\001${RED}\002\u25CF\001${RST}\002" ; ;;
            '??'*)         unt="\001${BLU}\002\u25CF\001${RST}\002" ; ;;
            'A'*)          new="\001${GRN}\002\u25CF\001${RST}\002" ; ;;
            'C'*)          cpd="\001${CYN}\002\u25CF\001${RST}\002" ; ;;
            'R'*)          rnm="\001${MAG}\002\u25CF\001${RST}\002" ; ;;
          esac
      done

      bits="${dty}${del}${unt}${new}${cpd}${rnm}"
      [ -n "${bits}" ] && echo -e "${bits}" || echo -e "\001${GRN}\002\u2714\001${RST}\002" 
  )
}

git_state() {
    if   [ -d "${gitdir}/rebase-merge" ] || [ -d "${gitdir}/rebase-apply" ]; then
        echo -e " (\001${GRN}\002rebasing\001${RST}\002)"
    elif [ -f "${gitdir}/MERGE_HEAD" ]; then
	echo -e " (\001${RED}\002merging\001${RST}\002)"
    elif [ -f "${gitdir}/CHERRY_PICK_HEAD" ]; then
	echo -e " (\001${BLU}\002cherry-picking\001${RST}\002)"
    elif [ -f "$g/REVERT_HEAD" ]; then
	echo -e " (\001${CYN}\002reverting\001${RST}\002)"
    elif [ -f "$g/BISECT_LOG" ]; then
	echo -e " (\001${MAG}\002bisecting\001${RST}\002)" 
    fi
}

git_upstream() {
    if [[ ! "$(cat ${prompt_cache})" = "${toplevel}" ]]; then
        git fetch -j 10 &>/dev/null &
        echo -n "${toplevel}" > "${prompt_cache}"
        echo -e " \u25CC" && return
    fi

    count="$(git rev-list --count --left-right @{upstream}...HEAD 2>/dev/null)"
    case "${count}" in
        "") 		echo -e " \u290F  \001${CYN}\002none\001${RST}\002"                 && return  ;; # no upstream
	"0	0") 	echo -e ""                                                          && return  ;; # equal to upstream
	"0	"*) 	echo -e " \u290F  \001${GRN}\002ahead ${count#0	}\001${RST}\002"    && return  ;; # ahead of upstream      (\u2193)
	*"	0") 	echo -e " \u290F  \001${MAG}\002behind ${count%	0}\001${RST}\002"   && return  ;; # behind upstream        (\u2191)
		 *)	echo -e " \u290F  \001${RED}\002diverged\001${RST}\002"             && return  ;; # diverged from upstream (\u21C5)	
    esac
}

exit_status() {
    [[ "${exit_stat}" != "0" ]] && echo -e "\001${RED}\002\u2718\001${RST}\002" || echo -e "\001${GRN}\002\u2714\001${RST}\002"
}

init_git_info_test() {
    repo_info="$(git rev-parse --show-prefix --abbrev-ref HEAD \
      --show-toplevel --git-dir --is-inside-git-dir            \
      --is-bare-repository --is-inside-work-tree               \
      --show-superproject-working-tree 2>/dev/null)"

    [[ "${?}" != "0" ]] && return

    parent_repo="${repo_info##*$'\n'}"
    if [[ "true" != "${parent_repo}" ]] && [[ "false" != "${parent_repo}" ]] && [[ "" != "${parent_repo}" ]]; then
      parent_repo="${parent_repo##*/} \u2016 "; repo_info="${repo_info%$'\n'*}"; else unset parent_repo; fi

    inside_worktree="${repo_info##*$'\n'}"
    repo_info="${repo_info%$'\n'*}"
    bare_repo="${repo_info##*$'\n'}"
    repo_info="${repo_info%$'\n'*}"
    inside_gitdir="${repo_info##*$'\n'}"
    repo_info="${repo_info%$'\n'*}"
    gitdir="${repo_info##*$'\n'}"
    repo_info="${repo_info%$'\n'*}"
    
    [[ "true" = "${inside_gitdir}" ]] \
      && toplevel="${parent_repo}$(basename $(git ls-remote --get-url) .git)" \
      || toplevel="${parent_repo}$(basename ${repo_info##*$'\n'})"; repo_info="${repo_info%$'\n'*}"

    [[ "${repo_info##*$'\n'}" = "HEAD" ]] \
      && branch=":$(git rev-parse --short HEAD)" \
      || branch="${repo_info##*$'\n'}"; repo_info="${repo_info%$'\n'*}"

    [[ "${repo_info%$'\n'*}" != "" ]] \
      && prefix="/${repo_info##*$'\n'}"; prefix="${prefix::-1}"
}

dir_path() {
    if [ "true" = "${bare_repo}" ]; then
        dir_path="\001${PPL}\002${PWD/#$HOME/\~}\001${RST}\002 "
	git_info="[ \001${CYN}\002bare\001${RST}\002 ]"
    
    elif [ "true" = "${inside_gitdir}" ]; then
        dir_path="\001${PPL}\002${toplevel}/.git\001${RST}\002 "
	git_info="[ \001${RED}\002gitdir\001${RST}\002 ]"

    elif [ "true" = "${inside_worktree}" ]; then
        dir_path="\001${PPL}\002${toplevel}${prefix}\001${RST}\002 "
        git_info="[ ${branch}$(git_state)$(git_upstream) | $(git_status) ]"

    else
        dir_path="\001${PPL}\002${PWD/#$HOME/\~}\001${RST}\002"
    fi

    echo -e "${dir_path}${git_info}"
}

bash_prompt() {
    exit_stat="${?}"
    prompt_cache="${HOME}/.bashprofile/cache/prompt-cache"
    
    init_git_info_test

    printf '%s %s %s %s ' \
      "$(exit_status &)"  \
      "$(std_time24  &)"  \
      "$(dir_path    &)"  \
      "$(std_prompt  &)"
}

PS1='$(bash_prompt)'

